
### Введение

Имеется набор диалогов которые были собраны после распознавания аудиопотоков.
Данные содержат массив объектов с текстом и пометкой стороны говорящего (бот/человек).

Также есть HTTP сервис (NLU) который принимает текст и на основе вычислений определяет
к какому "намерению" он относится. 
Намерение - это просто текстовая метка, что подразумевается в этом тексте.

### Описание задачи

Требуется на основе предоставленных диалогов, обрабатывая их через сервис NLU -
построить дерево разговора по следующей логике:

1. Последовательно прочитать все диалоги из файлов
2. Определять намерение из ответа человека (is_bot:false)
3. На основе намерения делать разветвление разговора
4. Построить на этих данных общее дерево разговора для всех диалогов

В результате работы модуля мы должны получить граф который показывает различные
реакции (намерения) на фразы бота.

Пример:
```
[
  {
    "is_bot": true,
    "phrases": [
      "алло здравствуйте меня зовут ирина",
      "добрый вечер меня зовут Александр"
    ],
    "replies": [
      {
        "intent": "greeting",
        "is_bot": false,
        "phrases": [
           "да здравствуйте"
        ],
        "replies": [
          {
            "is_bot": true,
            "phrases": [
              "я звоню вам по поводу продажи квартиры"
            ],
            "replies": [
               ...
            ]
          }
        ]
      },
      {
        "intent": "default",
        "is_bot": false,
        "phrases": [
           "ничего не понимаю"
        ],
        "replies": [
          ...
        ]
      } 
    ]
]
```

### Формат API сервиса для распознавания текста

```
GET https://sandbox.twin24.ai/parse?q=<текст>
```

В ответе от сервера нас интересует поле **intent.name** в котором содержится название
намерения.

### Требования к реализации

1. В диалогах мы должны начинать обработку с первой фразы бота
2. При запросах к сервису нужно иметь возможность тротлинга, обработки ошибок и т.п.
3. При ревью проекта будут учитываться композиция классов, подход к оформлению кода
4. Код должен быть оформлен в виде репозитория (например на github). Лучше всего чтобы коммиты добавлялись по мере реализации.

